{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 3eebf581dc3f9810045b","webpack:///./src/expression.parser.ts"],"names":[],"mappings":"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","file":"goat.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"goat\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"goat\"] = factory();\n\telse\n\t\troot[\"goat\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3eebf581dc3f9810045b","const EQUALITY_REGEX = /^\\s*([!\\w\\.]+)\\s*([^\\w\\s|&]{1,3})?\\s*([^\\sˆ&|\\\\=)]+)?\\s*$/;\nconst EXPRESSION_REGEX = /([&|]{2})|([\\(\\)])|([!\\w\\.]+)\\s*([^\\w\\s|&]{1,3})?\\s*([^\\sˆ&|\\)]+)?/g;\nconst STRING_REGEX = /^['\"](.*)['\"]$/;\nconst NOT_REGEX = /^\\s*([!]+)\\s*(\\w+)\\s*$/;\nconst LOGICAL_OPERATORS = ['&&', '||'];\nconst RELATIONAL_OPERATORS = ['==', '!=', '===', '!==', '!', '>=', '<=', '>', '<'];\n\ntype Operatee = string | (() => boolean);\n\ninterface IKeyValue<T> {\n    [key: string]: T;\n}\n\ninterface IKeyFunction extends IKeyValue<() => boolean> {\n}\n\nconst fieldsCache: IKeyValue<string[]> = {};\n\nconst isBoolean = (value: string) => ['true', 'false'].indexOf(value) > -1;\n\nconst generateRandomKey = () => Math.floor((1 + Math.random()) * 0x100000000000000).toString(16).substring(1);\n\nconst matchExpression = (expression: string) => \n    expression.match(/([&|]{2})|([\\(\\)])|([!\\w\\.]+)\\s*([^\\w\\s|&]{1,3})?\\s*([^\\sˆ&|\\)]+)?/g);\n\nconst asFunction = (val: any) => typeof val === 'function' ? val() : val;\n\nconst getRegexMatchArray = (regex: RegExp, input: string) => {\n    let match: string[] = regex.exec(input) || [];\n    if (match.length === 0) return;\n    match = match.filter(m => m !== undefined);\n    match.shift();\n    return match;\n};\n\nconst getOperation = (operation: string, left: Operatee, right?: Operatee) => (<IKeyFunction>{\n    '==': () => asFunction(left) == asFunction(right),\n    '!=': () => asFunction(left) != asFunction(right),\n    '===': () => asFunction(left) === asFunction(right),\n    '!==': () => asFunction(left) !== asFunction(right),\n    '<=': () => asFunction(left) <= asFunction(right),\n    '=<': () => asFunction(left) <= asFunction(right),\n    '>=': () => asFunction(left) >= asFunction(right),\n    '=>': () => asFunction(left) >= asFunction(right),\n    '<': () => asFunction(left) < asFunction(right),\n    '>': () => asFunction(left) > asFunction(right),\n    '&&': () => asFunction(left) && asFunction(right),\n    '||': () => asFunction(left) || asFunction(right)\n})[operation];\n\nconst evaluateNot = (nots: string[], value: string, controller: IKeyValue<any>, parserToken: string) => {\n    let evaluate: Operatee;\n    nots.shift();\n    if (nots.length) {\n        evaluate = evaluateNot(nots, value, controller, parserToken);\n    }\n\n    return () => !asFunction(evaluate || getValue(value, controller, parserToken));\n};\n\nconst getPropertyEval = (obj: IKeyValue<any>, prop: string) => (() => obj[prop]);\n\nconst setField = (field: string, parserToken: string) => {\n    let cache = fieldsCache[parserToken];\n    if (!cache) {\n        cache = fieldsCache[parserToken] = [];\n    }\n    cache.push(field);\n};\n\nconst getValue = (m: any, controller: IKeyValue<any>, parserToken: string): any => {\n    let match;\n    if ((match = getRegexMatchArray(NOT_REGEX, m))) {\n        const nots = match[0].split('');\n        return evaluateNot(nots, match[1], controller, parserToken);\n    } else if (isBoolean(m)) {\n        return m === 'true';\n    } else if (m in controller) {\n        setField(m, parserToken);\n        return getPropertyEval(controller, m);\n    } else if (!isNaN(m)) {\n        return parseInt(m);\n    } else if ((match = STRING_REGEX.exec(m))) {\n        return match[1];\n    } else {\n        return m;\n    }\n};\n\nconst processExpression = (expression: any, controller: IKeyValue<any>, parserToken: string): () => boolean => {\n    let match;\n    if (!(expression instanceof Array)) {\n        expression = [expression];\n    }\n    if (expression.length === 1 && (match = getRegexMatchArray(EQUALITY_REGEX, <string>expression[0]))) {\n        const left = getValue(match[0], controller, parserToken);\n        const right = getValue(match[2], controller, parserToken);\n        const operation = match[1];\n        if (typeof left === 'function' && !right && !operation) {\n            expression[0] = left;\n        } else {\n            expression[0] = getOperation(match[1], left, right);\n        }\n    }\n\n    while (expression.length > 1 || typeof expression[0] !== 'function') {\n        let index = -1;\n        let leftIndex = 0;\n        let rightIndex = 0;\n        let left: () => boolean;\n        let right: () => boolean;\n\n        let subExpression = expression;\n        const indexLeftParenthesis = expression.lastIndexOf('(');\n        if (indexLeftParenthesis > -1) {\n            subExpression = subExpression.slice(indexLeftParenthesis + 1, subExpression.length);\n            const indexRightParenthesis = subExpression.indexOf(')');\n            subExpression = subExpression.slice(0, indexRightParenthesis);\n            const expressionLength = subExpression.length;\n            expression[indexLeftParenthesis] = processExpression(subExpression, controller, parserToken);\n            expression.splice(indexLeftParenthesis + 1, expressionLength + 1);\n\n            continue;\n        }\n\n\n        if ((index = expression.indexOf('&&')) > -1 && \n            (expression[leftIndex = index - 1] !== ')') &&\n            (expression[rightIndex = index + 1] !== '(')) {\n            left = processExpression(expression[leftIndex], controller, parserToken);\n            right = processExpression(expression[rightIndex], controller, parserToken);\n            expression[leftIndex] = getOperation('&&', <() => boolean>left, <() => boolean>right);\n            expression.splice(index, 2);\n\n            continue;\n        } else if ((index = expression.indexOf('||')) > -1 &&\n            (expression[leftIndex = index - 1] !== ')') &&\n            (expression[rightIndex = index + 1] !== '(')) {\n            left = processExpression(expression[leftIndex], controller, parserToken);\n            right = processExpression(expression[rightIndex], controller, parserToken);\n            expression[leftIndex] = getOperation('||', <() => boolean>left, <() => boolean>right);\n            expression.splice(index, 2);\n\n            continue;\n        }\n\n        break;\n    }\n\n    if (expression.length === 1) {\n        return expression[0];\n    };\n};\n\nconst buildEvaluator = (expression: string, controller: IKeyValue<any>, parserToken: string) => {\n    const match = matchExpression(expression) || [];\n    return processExpression(match, controller, parserToken);\n};\n\n/**\n * Expression parser class\n */\nexport default class {\n    private _evaluator: () => boolean;\n    private _fields: string[];\n    private _parserToken: string;\n\n    /**\n     * Object fields that were used in the expression.\n     */\n    public get fields(): string[] {\n        return this._fields;\n    }\n\n    /**\n     * Creates new instance of the ExpressionParser.\n     * @param _expression Expression to be parsed\n     * @param _controller Object with fields that will be evaluated\n     */\n    constructor (private _expression: string, private _controller: { [key: string]: any }) {\n        this._parserToken = generateRandomKey();\n    }\n    \n    /**\n     * Evaluates current instance of the Expression Parser and returns\n     * a boolean value based on the expression that was passed in the constructor.\n     */\n    public evaluate() {\n        if (!this._evaluator) {\n            this._evaluator = buildEvaluator(this._expression, this._controller, this._parserToken);\n            this._fields = fieldsCache[this._parserToken];\n            delete fieldsCache[this._parserToken];\n        }\n\n        return this._evaluator();\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/expression.parser.ts"],"sourceRoot":""}