{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///goat.min.js","webpack:///webpack/bootstrap 01507729731667e7a04e","webpack:///./src/evaluation.builder.ts","webpack:///./src/expression.parser.ts"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","EQUALITY_REGEX","STRING_REGEX","NOT_REGEX","fieldsCache","isBoolean","indexOf","isFunction","matchExpression","expression","match","asFunction","val","setFirstInExpression","getFirstInExpression","getRegexMatchArray","regex","input","exec","length","filter","undefined","shift","throwError","msg","_i","arguments","Error","join","throwInvalidOperationError","operator","getOperation","operation","left","right","==","!=","===","!==","<=",">=","<",">","&&","||","evaluateNot","nots","controller","parserToken","evaluate","getValue","getPropertyEval","obj","prop","setField","field","cache","push","untilTruthy","fns","every","fn","split","isNaN","parseInt","processLogicalOperation","index","leftIndex","rightIndex","processExpression","result","splice","processExplicitPrecedence","subExpression","indexLeftParenthesis","lastIndexOf","slice","indexRightParenthesis","expressionLength","processEquality","operatorFunc","Array","getFields","token","deleteFromCache","generateRandomKey","Math","floor","random","toString","substring","buildEvaluator","evaluator","evaluation_builder_1","default_1","_expression","_controller","_parserToken","_fields","_evaluator","default"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,OAAA,UAAAH,GACA,gBAAAC,SACAA,QAAA,KAAAD,IAEAD,EAAA,KAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAE,EAAAF,EACAG,GAAA,EACAV,WAUA,OANAK,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,GAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KA+DA,OAnCAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAG,EAAA,SAAAK,GAA2C,MAAAA,IAG3CR,EAAAS,EAAA,SAAAf,EAAAgB,EAAAC,GACAX,EAAAY,EAAAlB,EAAAgB,IACAG,OAAAC,eAAApB,EAAAgB,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAX,EAAAkB,EAAA,SAAAvB,GACA,GAAAgB,GAAAhB,KAAAwB,WACA,WAA2B,MAAAxB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAK,GAAAS,EAAAE,EAAA,IAAAA,GACAA,GAIAX,EAAAY,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAlB,KAAAe,EAAAC,IAGtDrB,EAAAwB,EAAA,GAGAxB,IAAAyB,EAAA,KDgBM,SAAU9B,EAAQD,EAASM,GAEjC,YAIAa,QAAOC,eAAepB,EAAS,cAAgBc,OAAO,GEnFtD,IAAMkB,GAAiB,4DACjBC,EAAe,iBACfC,EAAY,yBAqBZC,KAKAC,EAAY,SAACtB,GAAkB,OAAC,OAAQ,SAASuB,QAAQvB,IAAU,GACnEwB,EAAa,SAACpB,GAAW,MAAa,kBAANA,IAEhCqB,EAAkB,SAACC,GACrB,MAAAA,GAAWC,MAAM,wEAEfC,EAAa,SAACC,GAAa,MAAAL,GAAWK,GAAOA,IAAQA,GAErDC,EAAuB,SAACJ,EAAwB1B,GAAoB,MAAC0B,GAA+B,GAAK1B,GACzG+B,EAAuB,SAAqBL,GAA2B,MAAIA,GAA+B,IAE1GM,EAAqB,SAACC,EAAeC,GACvC,GAAIP,GAAkBM,EAAME,KAAKD,MACjC,IAAqB,IAAjBP,EAAMS,OAGV,MAFAT,GAAQA,EAAMU,OAAO,SAAAvC,GAAK,MAAMwC,UAANxC,IAC1B6B,EAAMY,QACCZ,GAGLa,EAAa,WFiEf,IEjEgB,GAAAC,MAAAC,EAAA,EAAAA,EAAAC,UAAAP,OAAAM,IAAAD,EAAAC,GAAAC,UAAAD,EAAuB,MAAM,IAAIE,OAAMH,EAAII,KAAK,MAC9DC,EAA6B,SAACC,GAAqB,MAAAP,GAAW,YAAYO,EAAQ,kBAElFC,EAAe,SAACC,EAAmBC,EAAgBC,GAAqB,OAC1EC,KAAM,WAAM,MAAAxB,GAAWsB,IAAStB,EAAWuB,IAC3CE,KAAM,WAAM,MAAAzB,GAAWsB,IAAStB,EAAWuB,IAC3CG,MAAO,WAAM,MAAA1B,GAAWsB,KAAUtB,EAAWuB,IAC7CI,MAAO,WAAM,MAAA3B,GAAWsB,KAAUtB,EAAWuB,IAC7CK,KAAM,WAAM,MAAA5B,GAAWsB,IAAStB,EAAWuB,IAC3CM,KAAM,WAAM,MAAA7B,GAAWsB,IAAStB,EAAWuB,IAC3CO,IAAK,WAAM,MAAA9B,GAAWsB,GAAQtB,EAAWuB,IACzCQ,IAAK,WAAM,MAAA/B,GAAWsB,GAAQtB,EAAWuB,IACzCS,KAAM,WAAM,MAAAhC,GAAWsB,IAAStB,EAAWuB,IAC3CU,KAAM,WAAM,MAAAjC,GAAWsB,IAAStB,EAAWuB,KAC5CF,IAEGa,EAAc,SAACC,EAAgB/D,EAAegE,EAA4BC,GAC5E,GAAIC,EAMJ,OALAH,GAAKxB,QACDwB,EAAK3B,SACL8B,EAAWJ,EAAYC,EAAM/D,EAAOgE,EAAYC,IAG7C,WAAM,OAACrC,EAAWsC,GAAYC,EAASnE,EAAOgE,EAAYC,MAG/DG,EAAkB,SAACC,EAAqBC,GAAiB,kBAAO,MAAAD,GAAIC,KAEpEC,EAAW,SAACC,EAAeP,GAC7B,GAAIQ,GAAQpD,EAAY4C,EACnBQ,KACDA,EAAQpD,EAAY4C,OAExBQ,EAAMC,KAAKF,IAGTG,EAAc,WFiEhB,IEjEiB,GAAAC,MAAAlC,EAAA,EAAAA,EAAAC,UAAAP,OAAAM,IAAAkC,EAAAlC,GAAAC,UAAAD,EAAuB,OAAAkC,GAAIC,MAAM,SAACC,GAAO,OAACA,OAKzDX,EAAW,SAACrE,EAAQkE,EAA4BC,GAClD,GAAItC,EACJ,IAAKA,EAAQK,EAAmBZ,EAAWtB,GAAK,CAE5C,MAAOgE,GADMnC,EAAM,GAAGoD,MAAM,IACHpD,EAAM,GAAIqC,EAAYC,GAC5C,MAAI3C,GAAUxB,GACJ,SAANA,EACAA,IAAKkE,IACZO,EAASzE,EAAGmE,GACLG,EAAgBJ,EAAYlE,IAC3BkF,MAAMlF,IAEN6B,EAAQR,EAAagB,KAAKrC,IAC3B6B,EAAM,GAEN7B,EAJAmF,SAASnF,IAQlBoF,EAA0B,SAACjC,EAAmBvB,EAAiBsC,EAA4BC,GAC7F,GAAIkB,IAAS,EACTC,EAAY,EACZC,EAAa,CACjB,KAAKF,EAAQzD,EAAWH,QAAQ0B,KAAe,GACJ,MAAtCvB,EAAW0D,EAAYD,EAAQ,IACQ,MAAvCzD,EAAW2D,EAAaF,EAAQ,GAAa,CAC9C,GAAIjC,GAAOoC,EAAkB5D,EAAW0D,GAAYpB,EAAYC,GAC5Dd,EAAQmC,EAAkB5D,EAAW2D,GAAarB,EAAYC,GAC5DsB,EAASvC,EAAaC,EAAWlB,EAAqBmB,GAAOnB,EAAqBoB,GAKxF,OAJKoC,IAAQzC,EAA2BG,GACxCvB,EAAW0D,GAAaG,EACxB7D,EAAW8D,OAAOL,EAAO,GAElBI,IAITE,EAA4B,SAAC/D,EAAiBsC,EAA4BC,GAC5E,GAAIyB,GAAgBhE,EACdiE,EAAuBjE,EAAWkE,YAAY,IACpD,IAAID,GAAwB,EAAG,CAC3BD,EAAgBA,EAAcG,MAAMF,EAAuB,EAAGD,EAActD,OAC5E,IAAM0D,GAAwBJ,EAAcnE,QAAQ,IACpDmE,GAAgBA,EAAcG,MAAM,EAAGC,EACvC,IAAMC,GAAmBL,EAActD,OACjCmD,EAASD,EAAkBI,EAAe1B,EAAYC,EAG5D,OAFAvC,GAAWiE,GAAwBJ,EACnC7D,EAAW8D,OAAOG,EAAuB,EAAGI,EAAmB,GACxDR,IAITS,EAAkB,SAACtE,EAAwBsC,EAA4BC,GACzE,GAAItC,GACAsE,CACJ,IAA0B,IAAtBvE,EAAWU,SAAiBT,EAAQK,EAAmBd,EAAgBa,EAA6BL,KAAe,CACnH,GAAMwB,GAAOiB,EAASxC,EAAM,GAAIqC,EAAYC,GACtCd,EAAQgB,EAASxC,EAAM,GAAIqC,EAAYC,GACvChB,EAAYtB,EAAM,EAWxB,OAPIsE,IAHAzE,EAAW0B,IAAUC,GAAUF,EAGhBD,EAAarB,EAAM,GAAIuB,EAAMC,GAF7BD,EAKd+C,GAAcnD,EAA2BnB,EAAM,IAEpDG,EAAqBJ,EAAYuE,GAE1BA,IAITX,EAAoB,SAAC5D,EAAwBsC,EAA4BC,GAY3E,MAXMvC,aAAsBwE,SACxBxE,GAAcA,IAGlBiD,EACI,WAAM,MAAAqB,GAAgBtE,EAAYsC,EAAYC,IAC9C,WAAM,MAAAwB,GAA0B/D,EAAYsC,EAAYC,IACxD,WAAM,MAAAiB,GAAwB,KAAMxD,EAAYsC,EAAYC,IAC5D,WAAM,MAAAiB,GAAwB,KAAMxD,EAAYsC,EAAYC,KAG5DvC,EAAWU,OAAS,IAAMZ,EAAWE,EAAW,IACzC4D,EAAkB5D,EAAYsC,EAAYC,GAE1CvC,EAOFxC,GAAAiH,UAAY,SAACC,GAAkB,MAAA/E,GAAY+E,IAC3ClH,EAAAmH,gBAAkB,SAACD,GAAkB,aAAO/E,GAAY+E,IAExDlH,EAAAoH,kBAAoB,WAAM,MAAAC,MAAKC,MAA4B,mBAArB,EAAID,KAAKE,WAA+BC,SAAS,IAAIC,UAAU,IAErGzH,EAAA0H,eAAiB,SAAClF,EAAoBsC,EAA4BC,GAC3E,GAAMtC,GAAQF,EAAgBC,OACxB6D,EAASD,EAAkB3D,EAAOqC,EAAYC,GAE9C4C,EAAY9E,EAAgCwD,EAClD,IAAsB,IAAlBA,EAAOnD,QAAgBZ,EAAWqF,GAClC,MAAOA,KFgET,SAAU1H,EAAQD,EAASM,GAEjC,YAEAa,QAAOC,eAAepB,EAAS,cAAgBc,OAAO,GGzQtD,IAAA8G,GAAAtH,EAAA,GAKAuH,EAAA,WAiBI,QAAAA,GAAqBC,EAA6BC,GAA7B3H,KAAA0H,cAA6B1H,KAAA2H,cAC9C3H,KAAK4H,aAAeJ,EAAAR,oBAgB5B,MA1BIjG,QAAAC,eAAWyG,EAAAjG,UAAA,UHgRPL,IGhRJ,WACI,MAAOnB,MAAK6H,SHkRZ3G,YAAY,EACZD,cAAc,IGnQXwG,EAAAjG,UAAAoD,SAAP,WAOI,MANK5E,MAAK8H,aACN9H,KAAK8H,WAAaN,EAAAF,eAAetH,KAAK0H,YAAa1H,KAAK2H,YAAa3H,KAAK4H,cAC1E5H,KAAK6H,QAAUL,EAAAX,UAAU7G,KAAK4H,cAC9BJ,EAAAT,gBAAgB/G,KAAK4H,eAGlB5H,KAAK8H,cAEpBL,IH0QA7H,GAAQmI,QAAUN","file":"goat.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"goat\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"goat\"] = factory();\n\telse\n\t\troot[\"goat\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"goat\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"goat\"] = factory();\n\telse\n\t\troot[\"goat\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* Constants\n----------------------------------------------------------------*/\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar EQUALITY_REGEX = /^\\s*([!\\w\\.]+)\\s*([^\\w\\s|&]{1,3})?\\s*([^\\sˆ&|\\\\=)]+)?\\s*$/;\nvar STRING_REGEX = /^['\"](.*)['\"]$/;\nvar NOT_REGEX = /^\\s*([!]+)\\s*(\\w+)\\s*$/;\nvar LOGICAL_OPERATORS = ['&&', '||'];\nvar RELATIONAL_OPERATORS = ['==', '!=', '===', '!==', '!', '>=', '<=', '>', '<'];\n/* Cache Variables\n----------------------------------------------------------------*/\nvar fieldsCache = {};\n/* Support Functions\n----------------------------------------------------------------*/\nvar isBoolean = function (value) { return ['true', 'false'].indexOf(value) > -1; };\nvar isFunction = function (o) { return typeof o === 'function'; };\nvar matchExpression = function (expression) {\n    return expression.match(/([&|]{2})|([\\(\\)])|([!\\w\\.]+)\\s*([^\\w\\s|&]{1,3})?\\s*([^\\sˆ&|\\)]+)?/g);\n};\nvar asFunction = function (val) { return isFunction(val) ? val() : val; };\nvar setFirstInExpression = function (expression, value) { return expression[0] = value; };\nvar getFirstInExpression = function (expression) { return expression[0]; };\nvar getRegexMatchArray = function (regex, input) {\n    var match = regex.exec(input) || [];\n    if (match.length === 0)\n        return;\n    match = match.filter(function (m) { return m !== undefined; });\n    match.shift();\n    return match;\n};\nvar throwError = function () {\n    var msg = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        msg[_i] = arguments[_i];\n    }\n    throw new Error(msg.join(''));\n};\nvar throwInvalidOperationError = function (operator) { return throwError(\"Operator \" + operator + \" is not valid\"); };\nvar getOperation = function (operation, left, right) { return {\n    '==': function () { return asFunction(left) == asFunction(right); },\n    '!=': function () { return asFunction(left) != asFunction(right); },\n    '===': function () { return asFunction(left) === asFunction(right); },\n    '!==': function () { return asFunction(left) !== asFunction(right); },\n    '<=': function () { return asFunction(left) <= asFunction(right); },\n    '>=': function () { return asFunction(left) >= asFunction(right); },\n    '<': function () { return asFunction(left) < asFunction(right); },\n    '>': function () { return asFunction(left) > asFunction(right); },\n    '&&': function () { return asFunction(left) && asFunction(right); },\n    '||': function () { return asFunction(left) || asFunction(right); }\n}[operation]; };\nvar evaluateNot = function (nots, value, controller, parserToken) {\n    var evaluate;\n    nots.shift();\n    if (nots.length) {\n        evaluate = evaluateNot(nots, value, controller, parserToken);\n    }\n    return function () { return !asFunction(evaluate || getValue(value, controller, parserToken)); };\n};\nvar getPropertyEval = function (obj, prop) { return (function () { return obj[prop]; }); };\nvar setField = function (field, parserToken) {\n    var cache = fieldsCache[parserToken];\n    if (!cache) {\n        cache = fieldsCache[parserToken] = [];\n    }\n    cache.push(field);\n};\nvar untilTruthy = function () {\n    var fns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fns[_i] = arguments[_i];\n    }\n    return fns.every(function (fn) { return !fn(); });\n};\n/* Processing Functions\n----------------------------------------------------------------*/\nvar getValue = function (m, controller, parserToken) {\n    var match;\n    if ((match = getRegexMatchArray(NOT_REGEX, m))) {\n        var nots = match[0].split('');\n        return evaluateNot(nots, match[1], controller, parserToken);\n    }\n    else if (isBoolean(m)) {\n        return m === 'true';\n    }\n    else if (m in controller) {\n        setField(m, parserToken);\n        return getPropertyEval(controller, m);\n    }\n    else if (!isNaN(m)) {\n        return parseInt(m);\n    }\n    else if ((match = STRING_REGEX.exec(m))) {\n        return match[1];\n    }\n    else {\n        return m;\n    }\n};\nvar processLogicalOperation = function (operation, expression, controller, parserToken) {\n    var index = -1;\n    var leftIndex = 0;\n    var rightIndex = 0;\n    if ((index = expression.indexOf(operation)) > -1 &&\n        (expression[leftIndex = index - 1] !== ')') &&\n        (expression[rightIndex = index + 1] !== '(')) {\n        var left = processExpression(expression[leftIndex], controller, parserToken);\n        var right = processExpression(expression[rightIndex], controller, parserToken);\n        var result = getOperation(operation, getFirstInExpression(left), getFirstInExpression(right));\n        if (!result)\n            throwInvalidOperationError(operation);\n        expression[leftIndex] = result;\n        expression.splice(index, 2);\n        return result;\n    }\n};\nvar processExplicitPrecedence = function (expression, controller, parserToken) {\n    var subExpression = expression;\n    var indexLeftParenthesis = expression.lastIndexOf('(');\n    if (indexLeftParenthesis > -1) {\n        subExpression = subExpression.slice(indexLeftParenthesis + 1, subExpression.length);\n        var indexRightParenthesis = subExpression.indexOf(')');\n        subExpression = subExpression.slice(0, indexRightParenthesis);\n        var expressionLength = subExpression.length;\n        var result = processExpression(subExpression, controller, parserToken);\n        expression[indexLeftParenthesis] = result;\n        expression.splice(indexLeftParenthesis + 1, expressionLength + 1);\n        return result;\n    }\n};\nvar processEquality = function (expression, controller, parserToken) {\n    var match;\n    var operatorFunc;\n    if (expression.length === 1 && (match = getRegexMatchArray(EQUALITY_REGEX, getFirstInExpression(expression)))) {\n        var left = getValue(match[0], controller, parserToken);\n        var right = getValue(match[2], controller, parserToken);\n        var operation = match[1];\n        if (isFunction(left) && !right && !operation) {\n            operatorFunc = left;\n        }\n        else {\n            operatorFunc = getOperation(match[1], left, right);\n        }\n        if (!operatorFunc)\n            throwInvalidOperationError(match[1]);\n        setFirstInExpression(expression, operatorFunc);\n        return operatorFunc;\n    }\n};\nvar processExpression = function (expression, controller, parserToken) {\n    if (!(expression instanceof Array)) {\n        expression = [expression];\n    }\n    untilTruthy(function () { return processEquality(expression, controller, parserToken); }, function () { return processExplicitPrecedence(expression, controller, parserToken); }, function () { return processLogicalOperation('&&', expression, controller, parserToken); }, function () { return processLogicalOperation('||', expression, controller, parserToken); });\n    if (expression.length > 1 || !isFunction(expression[0])) {\n        return processExpression(expression, controller, parserToken);\n    }\n    else {\n        return expression;\n    }\n};\n/* Exported Functions\n----------------------------------------------------------------*/\nexports.getFields = function (token) { return fieldsCache[token]; };\nexports.deleteFromCache = function (token) { return delete fieldsCache[token]; };\nexports.generateRandomKey = function () { return Math.floor((1 + Math.random()) * 0x100000000000000).toString(16).substring(1); };\nexports.buildEvaluator = function (expression, controller, parserToken) {\n    var match = matchExpression(expression) || [];\n    var result = processExpression(match, controller, parserToken);\n    var evaluator = getFirstInExpression(result);\n    if (result.length === 1 && isFunction(evaluator)) {\n        return evaluator;\n    }\n    ;\n};\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar evaluation_builder_1 = __webpack_require__(0);\n/**\n * Expression parser class\n */\nvar default_1 = (function () {\n    /**\n     * Creates new instance of the ExpressionParser.\n     * @param _expression Expression to be parsed\n     * @param _controller Object with fields that will be evaluated\n     */\n    function default_1(_expression, _controller) {\n        this._expression = _expression;\n        this._controller = _controller;\n        this._parserToken = evaluation_builder_1.generateRandomKey();\n    }\n    Object.defineProperty(default_1.prototype, \"fields\", {\n        /**\n         * Object fields that were used in the expression.\n         */\n        get: function () {\n            return this._fields;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Evaluates current instance of the Expression Parser and returns\n     * a boolean value based on the expression that was passed in the constructor.\n     */\n    default_1.prototype.evaluate = function () {\n        if (!this._evaluator) {\n            this._evaluator = evaluation_builder_1.buildEvaluator(this._expression, this._controller, this._parserToken);\n            this._fields = evaluation_builder_1.getFields(this._parserToken);\n            evaluation_builder_1.deleteFromCache(this._parserToken);\n        }\n        return this._evaluator();\n    };\n    return default_1;\n}());\nexports.default = default_1;\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// goat.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 01507729731667e7a04e","/* Constants\n----------------------------------------------------------------*/\n\nconst EQUALITY_REGEX = /^\\s*([!\\w\\.]+)\\s*([^\\w\\s|&]{1,3})?\\s*([^\\sˆ&|\\\\=)]+)?\\s*$/;\nconst STRING_REGEX = /^['\"](.*)['\"]$/;\nconst NOT_REGEX = /^\\s*([!]+)\\s*(\\w+)\\s*$/;\nconst LOGICAL_OPERATORS = ['&&', '||'];\nconst RELATIONAL_OPERATORS = ['==', '!=', '===', '!==', '!', '>=', '<=', '>', '<'];\n\n/* Types\n----------------------------------------------------------------*/\n\ntype Evaluator = () => boolean;\ntype Operatee = string | Evaluator;\ntype Expression = RegExpMatchArray | Array<Operatee>;\n\nexport interface IKeyValue<T> {\n    [key: string]: T;\n}\n\nexport interface IKeyFunction extends IKeyValue<() => boolean> {\n}\n\n/* Cache Variables\n----------------------------------------------------------------*/\n\nconst fieldsCache: IKeyValue<string[]> = {};\n\n/* Support Functions\n----------------------------------------------------------------*/\n\nconst isBoolean = (value: string) => ['true', 'false'].indexOf(value) > -1;\nconst isFunction = (o: any) => typeof o === 'function';\n\nconst matchExpression = (expression: string) => \n    expression.match(/([&|]{2})|([\\(\\)])|([!\\w\\.]+)\\s*([^\\w\\s|&]{1,3})?\\s*([^\\sˆ&|\\)]+)?/g);\n\nconst asFunction = (val: any) => isFunction(val) ? val() : val;\n\nconst setFirstInExpression = (expression: Expression, value: Operatee) => (expression as Array<Operatee>)[0] = value;\nconst getFirstInExpression = <T extends Operatee>(expression: Expression) => <T>(expression as Array<Operatee>)[0];\n\nconst getRegexMatchArray = (regex: RegExp, input: string) => {\n    let match: string[] = regex.exec(input) || [];\n    if (match.length === 0) return;\n    match = match.filter(m => m !== undefined);\n    match.shift();\n    return match;\n};\n\nconst throwError = (...msg: string[]) => { throw new Error(msg.join('')); };\nconst throwInvalidOperationError = (operator: string) => throwError(`Operator ${operator} is not valid`);\n\nconst getOperation = (operation: string, left: Operatee, right?: Operatee) => (<IKeyFunction>{\n    '==': () => asFunction(left) == asFunction(right),\n    '!=': () => asFunction(left) != asFunction(right),\n    '===': () => asFunction(left) === asFunction(right),\n    '!==': () => asFunction(left) !== asFunction(right),\n    '<=': () => asFunction(left) <= asFunction(right),\n    '>=': () => asFunction(left) >= asFunction(right),\n    '<': () => asFunction(left) < asFunction(right),\n    '>': () => asFunction(left) > asFunction(right),\n    '&&': () => asFunction(left) && asFunction(right),\n    '||': () => asFunction(left) || asFunction(right)\n})[operation];\n\nconst evaluateNot = (nots: string[], value: string, controller: IKeyValue<any>, parserToken: string) => {\n    let evaluate: Operatee;\n    nots.shift();\n    if (nots.length) {\n        evaluate = evaluateNot(nots, value, controller, parserToken);\n    }\n\n    return () => !asFunction(evaluate || getValue(value, controller, parserToken));\n};\n\nconst getPropertyEval = (obj: IKeyValue<any>, prop: string) => (() => obj[prop]);\n\nconst setField = (field: string, parserToken: string) => {\n    let cache = fieldsCache[parserToken];\n    if (!cache) {\n        cache = fieldsCache[parserToken] = [];\n    }\n    cache.push(field);\n};\n\nconst untilTruthy = (...fns: Function[]) => fns.every((fn) => !fn());\n\n/* Processing Functions\n----------------------------------------------------------------*/\n\nconst getValue = (m: any, controller: IKeyValue<any>, parserToken: string): any => {\n    let match;\n    if ((match = getRegexMatchArray(NOT_REGEX, m))) {\n        const nots = match[0].split('');\n        return evaluateNot(nots, match[1], controller, parserToken);\n    } else if (isBoolean(m)) {\n        return m === 'true';\n    } else if (m in controller) {\n        setField(m, parserToken);\n        return getPropertyEval(controller, m);\n    } else if (!isNaN(m)) {\n        return parseInt(m);\n    } else if ((match = STRING_REGEX.exec(m))) {\n        return match[1];\n    } else {\n        return m;\n    }\n};\n\nconst processLogicalOperation = (operation: string, expression: any, controller: IKeyValue<any>, parserToken: string) => {\n    let index = -1;\n    let leftIndex = 0;\n    let rightIndex = 0;\n    if ((index = expression.indexOf(operation)) > -1 && \n        (expression[leftIndex = index - 1] !== ')') &&\n        (expression[rightIndex = index + 1] !== '(')) {\n        let left = processExpression(expression[leftIndex], controller, parserToken);\n        let right = processExpression(expression[rightIndex], controller, parserToken);\n        const result = getOperation(operation, getFirstInExpression(left), getFirstInExpression(right));\n        if (!result) throwInvalidOperationError(operation);\n        expression[leftIndex] = result;\n        expression.splice(index, 2);\n\n        return result;\n    }\n};\n\nconst processExplicitPrecedence = (expression: any, controller: IKeyValue<any>, parserToken: string) => {\n    let subExpression = expression;\n    const indexLeftParenthesis = expression.lastIndexOf('(');\n    if (indexLeftParenthesis > -1) {\n        subExpression = subExpression.slice(indexLeftParenthesis + 1, subExpression.length);\n        const indexRightParenthesis = subExpression.indexOf(')');\n        subExpression = subExpression.slice(0, indexRightParenthesis);\n        const expressionLength = subExpression.length;\n        const result = processExpression(subExpression, controller, parserToken);\n        expression[indexLeftParenthesis] = result;\n        expression.splice(indexLeftParenthesis + 1, expressionLength + 1);\n        return result;\n    }\n};\n\nconst processEquality = (expression: Expression, controller: IKeyValue<any>, parserToken: string) => {\n    let match: RegExpMatchArray;\n    let operatorFunc: Evaluator;\n    if (expression.length === 1 && (match = getRegexMatchArray(EQUALITY_REGEX, getFirstInExpression<string>(expression)))) {\n        const left = getValue(match[0], controller, parserToken);\n        const right = getValue(match[2], controller, parserToken);\n        const operation = match[1];\n        if (isFunction(left) && !right && !operation) {\n            operatorFunc = left as () => boolean;\n        } else {\n            operatorFunc = getOperation(match[1], left, right);\n        }\n\n        if (!operatorFunc) throwInvalidOperationError(match[1]);\n\n        setFirstInExpression(expression, operatorFunc);\n\n        return operatorFunc;\n    }\n};\n\nconst processExpression = (expression: Expression, controller: IKeyValue<any>, parserToken: string): Expression => {\n    if (!(expression instanceof Array)) {\n        expression = [expression];\n    }\n\n    untilTruthy(\n        () => processEquality(expression, controller, parserToken),\n        () => processExplicitPrecedence(expression, controller, parserToken),\n        () => processLogicalOperation('&&', expression, controller, parserToken),\n        () => processLogicalOperation('||', expression, controller, parserToken)\n    );\n\n    if (expression.length > 1 || !isFunction(expression[0])) {\n        return processExpression(expression, controller, parserToken);\n    } else {\n        return expression;\n    }\n};\n\n/* Exported Functions\n----------------------------------------------------------------*/\n\nexport const getFields = (token: string) => fieldsCache[token];\nexport const deleteFromCache = (token: string) => delete fieldsCache[token];\n\nexport const generateRandomKey = () => Math.floor((1 + Math.random()) * 0x100000000000000).toString(16).substring(1);\n\nexport const buildEvaluator = (expression: string, controller: IKeyValue<any>, parserToken: string): Evaluator => {\n    const match = matchExpression(expression) || [];\n    const result = processExpression(match, controller, parserToken);\n\n    const evaluator = getFirstInExpression<Evaluator>(result);\n    if (result.length === 1 && isFunction(evaluator)) {\n        return evaluator;\n    };\n};\n\n\n// WEBPACK FOOTER //\n// ./src/evaluation.builder.ts","import { generateRandomKey, buildEvaluator, getFields, deleteFromCache } from './evaluation.builder';\n\n/**\n * Expression parser class\n */\nexport default class {\n    private _evaluator: () => boolean;\n    private _fields: string[];\n    private _parserToken: string;\n\n    /**\n     * Object fields that were used in the expression.\n     */\n    public get fields(): string[] {\n        return this._fields;\n    }\n\n    /**\n     * Creates new instance of the ExpressionParser.\n     * @param _expression Expression to be parsed\n     * @param _controller Object with fields that will be evaluated\n     */\n    constructor (private _expression: string, private _controller: { [key: string]: any }) {\n        this._parserToken = generateRandomKey();\n    }\n    \n    /**\n     * Evaluates current instance of the Expression Parser and returns\n     * a boolean value based on the expression that was passed in the constructor.\n     */\n    public evaluate() {\n        if (!this._evaluator) {\n            this._evaluator = buildEvaluator(this._expression, this._controller, this._parserToken);\n            this._fields = getFields(this._parserToken);\n            deleteFromCache(this._parserToken);\n        }\n\n        return this._evaluator();\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/expression.parser.ts"],"sourceRoot":""}