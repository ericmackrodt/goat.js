{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///goat.min.js","webpack:///webpack/bootstrap 5b82a0c9f3bf45bd7519","webpack:///./src/expression.parser.ts"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","EQUALITY_REGEX","STRING_REGEX","NOT_REGEX","fieldsCache","isBoolean","indexOf","generateRandomKey","Math","floor","random","toString","substring","matchExpression","expression","match","asFunction","val","getRegexMatchArray","regex","input","exec","length","filter","undefined","shift","getOperation","operation","left","right","==","!=","===","!==","<=","=<",">=","=>","<",">","&&","||","evaluateNot","nots","controller","parserToken","evaluate","getValue","getPropertyEval","obj","prop","setField","field","cache","push","split","isNaN","parseInt","processExpression","Array","index","leftIndex","rightIndex","subExpression","indexLeftParenthesis","lastIndexOf","slice","indexRightParenthesis","expressionLength","splice","buildEvaluator","default_1","_expression","_controller","_parserToken","_fields","_evaluator","default"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,OAAA,UAAAH,GACA,gBAAAC,SACAA,QAAA,KAAAD,IAEAD,EAAA,KAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAE,EAAAF,EACAG,GAAA,EACAV,WAUA,OANAK,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,GAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KA+DA,OAnCAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAG,EAAA,SAAAK,GAA2C,MAAAA,IAG3CR,EAAAS,EAAA,SAAAf,EAAAgB,EAAAC,GACAX,EAAAY,EAAAlB,EAAAgB,IACAG,OAAAC,eAAApB,EAAAgB,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAX,EAAAkB,EAAA,SAAAvB,GACA,GAAAgB,GAAAhB,KAAAwB,WACA,WAA2B,MAAAxB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAK,GAAAS,EAAAE,EAAA,IAAAA,GACAA,GAIAX,EAAAY,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAlB,KAAAe,EAAAC,IAGtDrB,EAAAwB,EAAA,GAGAxB,IAAAyB,EAAA,KDgBM,SAAU9B,EAAQD,EAASM,GAEjC,YAEAa,QAAOC,eAAepB,EAAS,cAAgBc,OAAO,GEpFtD,IAAMkB,GAAiB,4DAEjBC,EAAe,iBACfC,EAAY,yBAaZC,KAEAC,EAAY,SAACtB,GAAkB,OAAC,OAAQ,SAASuB,QAAQvB,IAAU,GAEnEwB,EAAoB,WAAM,MAAAC,MAAKC,MAA4B,mBAArB,EAAID,KAAKE,WAA+BC,SAAS,IAAIC,UAAU,IAErGC,EAAkB,SAACC,GACrB,MAAAA,GAAWC,MAAM,wEAEfC,EAAa,SAACC,GAAa,MAAe,kBAARA,GAAqBA,IAAQA,GAE/DC,EAAqB,SAACC,EAAeC,GACvC,GAAIL,GAAkBI,EAAME,KAAKD,MACjC,IAAqB,IAAjBL,EAAMO,OAGV,MAFAP,GAAQA,EAAMQ,OAAO,SAAA1C,GAAK,MAAM2C,UAAN3C,IAC1BkC,EAAMU,QACCV,GAGLW,EAAe,SAACC,EAAmBC,EAAgBC,GAAqB,OAC1EC,KAAM,WAAM,MAAAd,GAAWY,IAASZ,EAAWa,IAC3CE,KAAM,WAAM,MAAAf,GAAWY,IAASZ,EAAWa,IAC3CG,MAAO,WAAM,MAAAhB,GAAWY,KAAUZ,EAAWa,IAC7CI,MAAO,WAAM,MAAAjB,GAAWY,KAAUZ,EAAWa,IAC7CK,KAAM,WAAM,MAAAlB,GAAWY,IAASZ,EAAWa,IAC3CM,KAAM,WAAM,MAAAnB,GAAWY,IAASZ,EAAWa,IAC3CO,KAAM,WAAM,MAAApB,GAAWY,IAASZ,EAAWa,IAC3CQ,KAAM,WAAM,MAAArB,GAAWY,IAASZ,EAAWa,IAC3CS,IAAK,WAAM,MAAAtB,GAAWY,GAAQZ,EAAWa,IACzCU,IAAK,WAAM,MAAAvB,GAAWY,GAAQZ,EAAWa,IACzCW,KAAM,WAAM,MAAAxB,GAAWY,IAASZ,EAAWa,IAC3CY,KAAM,WAAM,MAAAzB,GAAWY,IAASZ,EAAWa,KAC5CF,IAEGe,EAAc,SAACC,EAAgB5D,EAAe6D,EAA4BC,GAC5E,GAAIC,EAMJ,OALAH,GAAKlB,QACDkB,EAAKrB,SACLwB,EAAWJ,EAAYC,EAAM5D,EAAO6D,EAAYC,IAG7C,WAAM,OAAC7B,EAAW8B,GAAYC,EAAShE,EAAO6D,EAAYC,MAG/DG,EAAkB,SAACC,EAAqBC,GAAiB,kBAAO,MAAAD,GAAIC,KAEpEC,EAAW,SAACC,EAAeP,GAC7B,GAAIQ,GAAQjD,EAAYyC,EACnBQ,KACDA,EAAQjD,EAAYyC,OAExBQ,EAAMC,KAAKF,IAGTL,EAAW,SAAClE,EAAQ+D,EAA4BC,GAClD,GAAI9B,EACJ,IAAKA,EAAQG,EAAmBf,EAAWtB,GAAK,CAE5C,MAAO6D,GADM3B,EAAM,GAAGwC,MAAM,IACHxC,EAAM,GAAI6B,EAAYC,GAC5C,MAAIxC,GAAUxB,GACJ,SAANA,EACAA,IAAK+D,IACZO,EAAStE,EAAGgE,GACLG,EAAgBJ,EAAY/D,IAC3B2E,MAAM3E,IAENkC,EAAQb,EAAamB,KAAKxC,IAC3BkC,EAAM,GAENlC,EAJA4E,SAAS5E,IAQlB6E,EAAoB,SAAC5C,EAAiB8B,EAA4BC,GACpE,GAAI9B,EAIJ,IAHMD,YAAsB6C,SACxB7C,GAAcA,IAEQ,IAAtBA,EAAWQ,SAAiBP,EAAQG,EAAmBjB,EAAwBa,EAAW,KAAM,CAChG,GAAMc,GAAOmB,EAAShC,EAAM,GAAI6B,EAAYC,GACtChB,EAAQkB,EAAShC,EAAM,GAAI6B,EAAYC,GACvClB,EAAYZ,EAAM,EAIpBD,GAAW,GAHK,kBAATc,IAAwBC,GAAUF,EAGzBD,EAAaX,EAAM,GAAIa,EAAMC,GAF7BD,EAMxB,KAAOd,EAAWQ,OAAS,GAA8B,kBAAlBR,GAAW,IAAmB,CACjE,GAAI8C,IAAS,EACTC,EAAY,EACZC,EAAa,EACblC,EAAI,OACJC,EAAK,OAELkC,EAAgBjD,EACdkD,EAAuBlD,EAAWmD,YAAY,IACpD,IAAID,GAAwB,EAA5B,CACID,EAAgBA,EAAcG,MAAMF,EAAuB,EAAGD,EAAczC,OAC5E,IAAM6C,GAAwBJ,EAAczD,QAAQ,IACpDyD,GAAgBA,EAAcG,MAAM,EAAGC,EACvC,IAAMC,GAAmBL,EAAczC,MACvCR,GAAWkD,GAAwBN,EAAkBK,EAAenB,EAAYC,GAChF/B,EAAWuD,OAAOL,EAAuB,EAAGI,EAAmB,OAMnE,KAAKR,EAAQ9C,EAAWR,QAAQ,QAAU,GACC,MAAtCQ,EAAW+C,EAAYD,EAAQ,IACQ,MAAvC9C,EAAWgD,EAAaF,EAAQ,GACjChC,EAAO8B,EAAkB5C,EAAW+C,GAAYjB,EAAYC,GAC5DhB,EAAQ6B,EAAkB5C,EAAWgD,GAAalB,EAAYC,GAC9D/B,EAAW+C,GAAanC,EAAa,KAAqBE,EAAqBC,GAC/Ef,EAAWuD,OAAOT,EAAO,OAN7B,CASO,MAAKA,EAAQ9C,EAAWR,QAAQ,QAAU,GACN,MAAtCQ,EAAW+C,EAAYD,EAAQ,IACQ,MAAvC9C,EAAWgD,EAAaF,EAAQ,IASrC,KARIhC,GAAO8B,EAAkB5C,EAAW+C,GAAYjB,EAAYC,GAC5DhB,EAAQ6B,EAAkB5C,EAAWgD,GAAalB,EAAYC,GAC9D/B,EAAW+C,GAAanC,EAAa,KAAqBE,EAAqBC,GAC/Ef,EAAWuD,OAAOT,EAAO,IAQjC,GAA0B,IAAtB9C,EAAWQ,OACX,MAAOR,GAAW,IAIpBwD,EAAiB,SAACxD,EAAoB8B,EAA4BC,GAEpE,MAAOa,GADO7C,EAAgBC,OACE8B,EAAYC,IAMhD0B,EAAA,WAiBI,QAAAA,GAAqBC,EAA6BC,GAA7BpG,KAAAmG,cAA6BnG,KAAAoG,cAC9CpG,KAAKqG,aAAenE,IAgB5B,MA1BInB,QAAAC,eAAWkF,EAAA1E,UAAA,UFqEPL,IErEJ,WACI,MAAOnB,MAAKsG,SFuEZpF,YAAY,EACZD,cAAc,IExDXiF,EAAA1E,UAAAiD,SAAP,WAOI,MANKzE,MAAKuG,aACNvG,KAAKuG,WAAaN,EAAejG,KAAKmG,YAAanG,KAAKoG,YAAapG,KAAKqG,cAC1ErG,KAAKsG,QAAUvE,EAAY/B,KAAKqG,oBACzBtE,GAAY/B,KAAKqG,eAGrBrG,KAAKuG,cAEpBL,IF+DAtG,GAAQ4G,QAAUN","file":"goat.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"goat\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"goat\"] = factory();\n\telse\n\t\troot[\"goat\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"goat\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"goat\"] = factory();\n\telse\n\t\troot[\"goat\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar EQUALITY_REGEX = /^\\s*([!\\w\\.]+)\\s*([^\\w\\s|&]{1,3})?\\s*([^\\sˆ&|\\\\=)]+)?\\s*$/;\nvar EXPRESSION_REGEX = /([&|]{2})|([\\(\\)])|([!\\w\\.]+)\\s*([^\\w\\s|&]{1,3})?\\s*([^\\sˆ&|\\)]+)?/g;\nvar STRING_REGEX = /^['\"](.*)['\"]$/;\nvar NOT_REGEX = /^\\s*([!]+)\\s*(\\w+)\\s*$/;\nvar LOGICAL_OPERATORS = ['&&', '||'];\nvar RELATIONAL_OPERATORS = ['==', '!=', '===', '!==', '!', '>=', '<=', '>', '<'];\nvar fieldsCache = {};\nvar isBoolean = function (value) { return ['true', 'false'].indexOf(value) > -1; };\nvar generateRandomKey = function () { return Math.floor((1 + Math.random()) * 0x100000000000000).toString(16).substring(1); };\nvar matchExpression = function (expression) {\n    return expression.match(/([&|]{2})|([\\(\\)])|([!\\w\\.]+)\\s*([^\\w\\s|&]{1,3})?\\s*([^\\sˆ&|\\)]+)?/g);\n};\nvar asFunction = function (val) { return typeof val === 'function' ? val() : val; };\nvar getRegexMatchArray = function (regex, input) {\n    var match = regex.exec(input) || [];\n    if (match.length === 0)\n        return;\n    match = match.filter(function (m) { return m !== undefined; });\n    match.shift();\n    return match;\n};\nvar getOperation = function (operation, left, right) { return {\n    '==': function () { return asFunction(left) == asFunction(right); },\n    '!=': function () { return asFunction(left) != asFunction(right); },\n    '===': function () { return asFunction(left) === asFunction(right); },\n    '!==': function () { return asFunction(left) !== asFunction(right); },\n    '<=': function () { return asFunction(left) <= asFunction(right); },\n    '=<': function () { return asFunction(left) <= asFunction(right); },\n    '>=': function () { return asFunction(left) >= asFunction(right); },\n    '=>': function () { return asFunction(left) >= asFunction(right); },\n    '<': function () { return asFunction(left) < asFunction(right); },\n    '>': function () { return asFunction(left) > asFunction(right); },\n    '&&': function () { return asFunction(left) && asFunction(right); },\n    '||': function () { return asFunction(left) || asFunction(right); }\n}[operation]; };\nvar evaluateNot = function (nots, value, controller, parserToken) {\n    var evaluate;\n    nots.shift();\n    if (nots.length) {\n        evaluate = evaluateNot(nots, value, controller, parserToken);\n    }\n    return function () { return !asFunction(evaluate || getValue(value, controller, parserToken)); };\n};\nvar getPropertyEval = function (obj, prop) { return (function () { return obj[prop]; }); };\nvar setField = function (field, parserToken) {\n    var cache = fieldsCache[parserToken];\n    if (!cache) {\n        cache = fieldsCache[parserToken] = [];\n    }\n    cache.push(field);\n};\nvar getValue = function (m, controller, parserToken) {\n    var match;\n    if ((match = getRegexMatchArray(NOT_REGEX, m))) {\n        var nots = match[0].split('');\n        return evaluateNot(nots, match[1], controller, parserToken);\n    }\n    else if (isBoolean(m)) {\n        return m === 'true';\n    }\n    else if (m in controller) {\n        setField(m, parserToken);\n        return getPropertyEval(controller, m);\n    }\n    else if (!isNaN(m)) {\n        return parseInt(m);\n    }\n    else if ((match = STRING_REGEX.exec(m))) {\n        return match[1];\n    }\n    else {\n        return m;\n    }\n};\nvar processExpression = function (expression, controller, parserToken) {\n    var match;\n    if (!(expression instanceof Array)) {\n        expression = [expression];\n    }\n    if (expression.length === 1 && (match = getRegexMatchArray(EQUALITY_REGEX, expression[0]))) {\n        var left = getValue(match[0], controller, parserToken);\n        var right = getValue(match[2], controller, parserToken);\n        var operation = match[1];\n        if (typeof left === 'function' && !right && !operation) {\n            expression[0] = left;\n        }\n        else {\n            expression[0] = getOperation(match[1], left, right);\n        }\n    }\n    while (expression.length > 1 || typeof expression[0] !== 'function') {\n        var index = -1;\n        var leftIndex = 0;\n        var rightIndex = 0;\n        var left = void 0;\n        var right = void 0;\n        var subExpression = expression;\n        var indexLeftParenthesis = expression.lastIndexOf('(');\n        if (indexLeftParenthesis > -1) {\n            subExpression = subExpression.slice(indexLeftParenthesis + 1, subExpression.length);\n            var indexRightParenthesis = subExpression.indexOf(')');\n            subExpression = subExpression.slice(0, indexRightParenthesis);\n            var expressionLength = subExpression.length;\n            expression[indexLeftParenthesis] = processExpression(subExpression, controller, parserToken);\n            expression.splice(indexLeftParenthesis + 1, expressionLength + 1);\n            continue;\n        }\n        if ((index = expression.indexOf('&&')) > -1 &&\n            (expression[leftIndex = index - 1] !== ')') &&\n            (expression[rightIndex = index + 1] !== '(')) {\n            left = processExpression(expression[leftIndex], controller, parserToken);\n            right = processExpression(expression[rightIndex], controller, parserToken);\n            expression[leftIndex] = getOperation('&&', left, right);\n            expression.splice(index, 2);\n            continue;\n        }\n        else if ((index = expression.indexOf('||')) > -1 &&\n            (expression[leftIndex = index - 1] !== ')') &&\n            (expression[rightIndex = index + 1] !== '(')) {\n            left = processExpression(expression[leftIndex], controller, parserToken);\n            right = processExpression(expression[rightIndex], controller, parserToken);\n            expression[leftIndex] = getOperation('||', left, right);\n            expression.splice(index, 2);\n            continue;\n        }\n        break;\n    }\n    if (expression.length === 1) {\n        return expression[0];\n    }\n    ;\n};\nvar buildEvaluator = function (expression, controller, parserToken) {\n    var match = matchExpression(expression) || [];\n    return processExpression(match, controller, parserToken);\n};\n/**\n * Expression parser class\n */\nvar default_1 = (function () {\n    /**\n     * Creates new instance of the ExpressionParser.\n     * @param _expression Expression to be parsed\n     * @param _controller Object with fields that will be evaluated\n     */\n    function default_1(_expression, _controller) {\n        this._expression = _expression;\n        this._controller = _controller;\n        this._parserToken = generateRandomKey();\n    }\n    Object.defineProperty(default_1.prototype, \"fields\", {\n        /**\n         * Object fields that were used in the expression.\n         */\n        get: function () {\n            return this._fields;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Evaluates current instance of the Expression Parser and returns\n     * a boolean value based on the expression that was passed in the constructor.\n     */\n    default_1.prototype.evaluate = function () {\n        if (!this._evaluator) {\n            this._evaluator = buildEvaluator(this._expression, this._controller, this._parserToken);\n            this._fields = fieldsCache[this._parserToken];\n            delete fieldsCache[this._parserToken];\n        }\n        return this._evaluator();\n    };\n    return default_1;\n}());\nexports.default = default_1;\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// goat.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5b82a0c9f3bf45bd7519","const EQUALITY_REGEX = /^\\s*([!\\w\\.]+)\\s*([^\\w\\s|&]{1,3})?\\s*([^\\sˆ&|\\\\=)]+)?\\s*$/;\nconst EXPRESSION_REGEX = /([&|]{2})|([\\(\\)])|([!\\w\\.]+)\\s*([^\\w\\s|&]{1,3})?\\s*([^\\sˆ&|\\)]+)?/g;\nconst STRING_REGEX = /^['\"](.*)['\"]$/;\nconst NOT_REGEX = /^\\s*([!]+)\\s*(\\w+)\\s*$/;\nconst LOGICAL_OPERATORS = ['&&', '||'];\nconst RELATIONAL_OPERATORS = ['==', '!=', '===', '!==', '!', '>=', '<=', '>', '<'];\n\ntype Operatee = string | (() => boolean);\n\ninterface IKeyValue<T> {\n    [key: string]: T;\n}\n\ninterface IKeyFunction extends IKeyValue<() => boolean> {\n}\n\nconst fieldsCache: IKeyValue<string[]> = {};\n\nconst isBoolean = (value: string) => ['true', 'false'].indexOf(value) > -1;\n\nconst generateRandomKey = () => Math.floor((1 + Math.random()) * 0x100000000000000).toString(16).substring(1);\n\nconst matchExpression = (expression: string) => \n    expression.match(/([&|]{2})|([\\(\\)])|([!\\w\\.]+)\\s*([^\\w\\s|&]{1,3})?\\s*([^\\sˆ&|\\)]+)?/g);\n\nconst asFunction = (val: any) => typeof val === 'function' ? val() : val;\n\nconst getRegexMatchArray = (regex: RegExp, input: string) => {\n    let match: string[] = regex.exec(input) || [];\n    if (match.length === 0) return;\n    match = match.filter(m => m !== undefined);\n    match.shift();\n    return match;\n};\n\nconst getOperation = (operation: string, left: Operatee, right?: Operatee) => (<IKeyFunction>{\n    '==': () => asFunction(left) == asFunction(right),\n    '!=': () => asFunction(left) != asFunction(right),\n    '===': () => asFunction(left) === asFunction(right),\n    '!==': () => asFunction(left) !== asFunction(right),\n    '<=': () => asFunction(left) <= asFunction(right),\n    '=<': () => asFunction(left) <= asFunction(right),\n    '>=': () => asFunction(left) >= asFunction(right),\n    '=>': () => asFunction(left) >= asFunction(right),\n    '<': () => asFunction(left) < asFunction(right),\n    '>': () => asFunction(left) > asFunction(right),\n    '&&': () => asFunction(left) && asFunction(right),\n    '||': () => asFunction(left) || asFunction(right)\n})[operation];\n\nconst evaluateNot = (nots: string[], value: string, controller: IKeyValue<any>, parserToken: string) => {\n    let evaluate: Operatee;\n    nots.shift();\n    if (nots.length) {\n        evaluate = evaluateNot(nots, value, controller, parserToken);\n    }\n\n    return () => !asFunction(evaluate || getValue(value, controller, parserToken));\n};\n\nconst getPropertyEval = (obj: IKeyValue<any>, prop: string) => (() => obj[prop]);\n\nconst setField = (field: string, parserToken: string) => {\n    let cache = fieldsCache[parserToken];\n    if (!cache) {\n        cache = fieldsCache[parserToken] = [];\n    }\n    cache.push(field);\n};\n\nconst getValue = (m: any, controller: IKeyValue<any>, parserToken: string): any => {\n    let match;\n    if ((match = getRegexMatchArray(NOT_REGEX, m))) {\n        const nots = match[0].split('');\n        return evaluateNot(nots, match[1], controller, parserToken);\n    } else if (isBoolean(m)) {\n        return m === 'true';\n    } else if (m in controller) {\n        setField(m, parserToken);\n        return getPropertyEval(controller, m);\n    } else if (!isNaN(m)) {\n        return parseInt(m);\n    } else if ((match = STRING_REGEX.exec(m))) {\n        return match[1];\n    } else {\n        return m;\n    }\n};\n\nconst processExpression = (expression: any, controller: IKeyValue<any>, parserToken: string): () => boolean => {\n    let match;\n    if (!(expression instanceof Array)) {\n        expression = [expression];\n    }\n    if (expression.length === 1 && (match = getRegexMatchArray(EQUALITY_REGEX, <string>expression[0]))) {\n        const left = getValue(match[0], controller, parserToken);\n        const right = getValue(match[2], controller, parserToken);\n        const operation = match[1];\n        if (typeof left === 'function' && !right && !operation) {\n            expression[0] = left;\n        } else {\n            expression[0] = getOperation(match[1], left, right);\n        }\n    }\n\n    while (expression.length > 1 || typeof expression[0] !== 'function') {\n        let index = -1;\n        let leftIndex = 0;\n        let rightIndex = 0;\n        let left: () => boolean;\n        let right: () => boolean;\n\n        let subExpression = expression;\n        const indexLeftParenthesis = expression.lastIndexOf('(');\n        if (indexLeftParenthesis > -1) {\n            subExpression = subExpression.slice(indexLeftParenthesis + 1, subExpression.length);\n            const indexRightParenthesis = subExpression.indexOf(')');\n            subExpression = subExpression.slice(0, indexRightParenthesis);\n            const expressionLength = subExpression.length;\n            expression[indexLeftParenthesis] = processExpression(subExpression, controller, parserToken);\n            expression.splice(indexLeftParenthesis + 1, expressionLength + 1);\n\n            continue;\n        }\n\n\n        if ((index = expression.indexOf('&&')) > -1 && \n            (expression[leftIndex = index - 1] !== ')') &&\n            (expression[rightIndex = index + 1] !== '(')) {\n            left = processExpression(expression[leftIndex], controller, parserToken);\n            right = processExpression(expression[rightIndex], controller, parserToken);\n            expression[leftIndex] = getOperation('&&', <() => boolean>left, <() => boolean>right);\n            expression.splice(index, 2);\n\n            continue;\n        } else if ((index = expression.indexOf('||')) > -1 &&\n            (expression[leftIndex = index - 1] !== ')') &&\n            (expression[rightIndex = index + 1] !== '(')) {\n            left = processExpression(expression[leftIndex], controller, parserToken);\n            right = processExpression(expression[rightIndex], controller, parserToken);\n            expression[leftIndex] = getOperation('||', <() => boolean>left, <() => boolean>right);\n            expression.splice(index, 2);\n\n            continue;\n        }\n\n        break;\n    }\n\n    if (expression.length === 1) {\n        return expression[0];\n    };\n};\n\nconst buildEvaluator = (expression: string, controller: IKeyValue<any>, parserToken: string) => {\n    const match = matchExpression(expression) || [];\n    return processExpression(match, controller, parserToken);\n};\n\n/**\n * Expression parser class\n */\nexport default class {\n    private _evaluator: () => boolean;\n    private _fields: string[];\n    private _parserToken: string;\n\n    /**\n     * Object fields that were used in the expression.\n     */\n    public get fields(): string[] {\n        return this._fields;\n    }\n\n    /**\n     * Creates new instance of the ExpressionParser.\n     * @param _expression Expression to be parsed\n     * @param _controller Object with fields that will be evaluated\n     */\n    constructor (private _expression: string, private _controller: { [key: string]: any }) {\n        this._parserToken = generateRandomKey();\n    }\n    \n    /**\n     * Evaluates current instance of the Expression Parser and returns\n     * a boolean value based on the expression that was passed in the constructor.\n     */\n    public evaluate() {\n        if (!this._evaluator) {\n            this._evaluator = buildEvaluator(this._expression, this._controller, this._parserToken);\n            this._fields = fieldsCache[this._parserToken];\n            delete fieldsCache[this._parserToken];\n        }\n\n        return this._evaluator();\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/expression.parser.ts"],"sourceRoot":""}