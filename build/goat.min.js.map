{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///goat.min.js","webpack:///webpack/bootstrap 3524004c0082023ff56e","webpack:///./src/evaluation.builder.ts","webpack:///./src/expression.parser.ts"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","EQUALITY_REGEX","STRING_REGEX","NOT_REGEX","LOGICAL_OPERATORS","expressionCache","isBoolean","indexOf","isFunction","includes","getMiddleItem","expression","Math","round","length","matchExpression","match","isProperty","test","asFunction","val","setFirstInExpression","getFirstInExpression","getRegexMatchArray","regex","input","exec","filter","undefined","shift","getExpression","token","throwError","msg","_i","arguments","Error","join","throwInvalidOperationError","operator","throwInvalidExpressionError","getOperation","operation","left","right","==","!=","===","!==","<=",">=","<",">","&&","||","evaluateNot","nots","controller","parserToken","evaluate","operand","processOperand","buildPropertyCaller","fields","lastFunction","last","pop","fn","obj","setField","field","cache","push","untilTruthy","fns","every","split","caller_1","isNaN","parseInt","processLogicalOperation","index","leftIndex","rightIndex","processExpression","result","splice","processExplicitPrecedence","subExpression","indexLeftParenthesis","lastIndexOf","slice","indexRightParenthesis","expressionLength","processEquality","operatorFunc","Array","getFields","deleteFromCache","generateRandomKey","floor","random","toString","substring","buildEvaluator","evaluation_builder_1","default_1","_expression","_controller","_parserToken","_fields","_evaluator","default"],"mappings":"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","file":"goat.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"goat\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"goat\"] = factory();\n\telse\n\t\troot[\"goat\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"goat\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"goat\"] = factory();\n\telse\n\t\troot[\"goat\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* Constants\n----------------------------------------------------------------*/\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar EQUALITY_REGEX = /^\\s*([^\\sˆ&|\\'\"\\(\\)]+|[\"'][^'\"]+[\"'])\\s*$|^\\s*([^\\sˆ&|\\'\"\\(\\)]+|[\"'][^'\"]*[\"'])\\s*([^'\"\\w\\s|&]{1,3})\\s*([^\\sˆ&|\\'\"\\(\\)]+|[\"'][^'\"]*[\"'])\\s*$/;\nvar STRING_REGEX = /^['\"](.*)['\"]$/;\nvar NOT_REGEX = /^\\s*([!]+)\\s*(\\w+)\\s*$/;\nvar LOGICAL_OPERATORS = ['&&', '||'];\nvar RELATIONAL_OPERATORS = ['==', '!=', '===', '!==', '!', '>=', '<=', '>', '<'];\n/* Cache Variables\n----------------------------------------------------------------*/\nvar expressionCache = {};\n/* Support Functions\n----------------------------------------------------------------*/\nvar isBoolean = function (value) { return ['true', 'false'].indexOf(value) > -1; };\nvar isFunction = function (o) { return typeof o === 'function'; };\nvar includes = function (o, value) { return o.indexOf(value) > -1; };\nvar getMiddleItem = function (expression) { return expression[Math.round((expression.length - 1) / 2)]; };\nvar matchExpression = function (expression) {\n    return expression.match(/([&|]{2})|([\\(\\)])|([^\\sˆ&|\\'\"\\(\\)]+|[\"'].+[\"'])\\s*([^\\w\\s|&\\(\\)]{1,3})?\\s*([^\\sˆ&|\\(\\)]+)?/g);\n};\nvar isProperty = function (expression) { return /^\\s*([a-z]\\w+)(\\.[a-z]\\w+)*\\s*$/g.test(expression); };\nvar asFunction = function (val) { return isFunction(val) ? val() : val; };\nvar setFirstInExpression = function (expression, value) { return expression[0] = value; };\nvar getFirstInExpression = function (expression) { return expression[0]; };\nvar getRegexMatchArray = function (regex, input) {\n    var match = regex.exec(input) || [];\n    if (match.length === 0)\n        return;\n    match = match.filter(function (m) { return m !== undefined; });\n    match.shift();\n    return match;\n};\nvar getExpression = function (token) { return expressionCache[token].expression; };\nvar throwError = function () {\n    var msg = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        msg[_i] = arguments[_i];\n    }\n    throw new Error(msg.join(''));\n};\nvar throwInvalidOperationError = function (operator, token) { return throwError(\"Operator [\" + operator + \"] is not valid in expression [\" + getExpression(token) + \"]\"); };\nvar throwInvalidExpressionError = function (token) { return throwError(\"Invalid expression [\" + getExpression(token) + \"]\"); };\nvar getOperation = function (operation, left, right) { return {\n    '==': function () { return asFunction(left) == asFunction(right); },\n    '!=': function () { return asFunction(left) != asFunction(right); },\n    '===': function () { return asFunction(left) === asFunction(right); },\n    '!==': function () { return asFunction(left) !== asFunction(right); },\n    '<=': function () { return asFunction(left) <= asFunction(right); },\n    '>=': function () { return asFunction(left) >= asFunction(right); },\n    '<': function () { return asFunction(left) < asFunction(right); },\n    '>': function () { return asFunction(left) > asFunction(right); },\n    '&&': function () { return asFunction(left) && asFunction(right); },\n    '||': function () { return asFunction(left) || asFunction(right); }\n}[operation]; };\nvar evaluateNot = function (nots, value, controller, parserToken) {\n    var evaluate;\n    nots.shift();\n    if (nots.length) {\n        evaluate = evaluateNot(nots, value, controller, parserToken);\n    }\n    var operand = processOperand(value, controller, parserToken);\n    return function () { return !asFunction(evaluate || operand); };\n};\nvar buildPropertyCaller = function (fields, lastFunction) {\n    var last = fields[fields.length - 1];\n    fields.pop();\n    // function that evaluates current property\n    var fn;\n    if (!lastFunction) {\n        fn = function (obj) { return obj[last]; };\n    }\n    else {\n        fn = function (obj) { return lastFunction(obj[last]); };\n    }\n    if (fields.length) {\n        return buildPropertyCaller(fields, fn);\n    }\n    return fn;\n};\nvar setField = function (field, parserToken) {\n    var cache = expressionCache[parserToken].fields;\n    if (!cache) {\n        cache = expressionCache[parserToken].fields = [];\n    }\n    cache.push(field);\n};\n/**\n * Executes functions in series until one of them returns a truthy value.\n * If it does, the function returns true.\n * @param fns Functions to be executed\n */\nvar untilTruthy = function () {\n    var fns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fns[_i] = arguments[_i];\n    }\n    return !fns.every(function (fn) { return !fn(); });\n};\n/* Processing Functions\n----------------------------------------------------------------*/\nvar processOperand = function (m, controller, parserToken) {\n    var match;\n    if ((match = getRegexMatchArray(NOT_REGEX, m))) {\n        var nots = match[0].split('');\n        return evaluateNot(nots, match[1], controller, parserToken);\n    }\n    else if (isBoolean(m)) {\n        return m === 'true';\n    }\n    else if (isProperty(m)) {\n        var caller_1 = buildPropertyCaller(m.split('.'));\n        setField(m, parserToken);\n        return function () { return caller_1(controller); };\n    }\n    else if (!isNaN(m)) {\n        return parseInt(m);\n    }\n    else if ((match = STRING_REGEX.exec(m))) {\n        return getMiddleItem(match);\n    }\n    throwInvalidExpressionError(parserToken);\n};\nvar processLogicalOperation = function (operation, expression, controller, parserToken) {\n    var index = -1;\n    var leftIndex = 0;\n    var rightIndex = 0;\n    if ((index = expression.indexOf(operation)) > -1 &&\n        (expression[leftIndex = index - 1] !== ')') &&\n        (expression[rightIndex = index + 1] !== '(')) {\n        var left = processExpression(expression[leftIndex], controller, parserToken);\n        var right = processExpression(expression[rightIndex], controller, parserToken);\n        var result = getOperation(operation, getFirstInExpression(left), getFirstInExpression(right));\n        expression[leftIndex] = result;\n        expression.splice(index, 2);\n        return result;\n    }\n};\nvar processExplicitPrecedence = function (expression, controller, parserToken) {\n    var subExpression = expression;\n    var indexLeftParenthesis = expression.lastIndexOf('(');\n    if (indexLeftParenthesis > -1) {\n        subExpression = subExpression.slice(indexLeftParenthesis + 1, subExpression.length);\n        var indexRightParenthesis = subExpression.indexOf(')');\n        subExpression = subExpression.slice(0, indexRightParenthesis);\n        var expressionLength = subExpression.length;\n        var result = processExpression(subExpression, controller, parserToken);\n        expression[indexLeftParenthesis] = result;\n        expression.splice(indexLeftParenthesis + 1, expressionLength + 1);\n        return result;\n    }\n};\nvar processEquality = function (expression, controller, parserToken) {\n    var match;\n    var operatorFunc;\n    if (expression.length === 1 && (match = getRegexMatchArray(EQUALITY_REGEX, getFirstInExpression(expression)))) {\n        var left = processOperand(match[0], controller, parserToken);\n        var right = match[2];\n        if (right) {\n            right = processOperand(match[2], controller, parserToken);\n        }\n        var operation = match[1];\n        if (isFunction(left) && !right && !operation) {\n            operatorFunc = left;\n        }\n        else {\n            operatorFunc = getOperation(match[1], left, right);\n        }\n        if (!operatorFunc)\n            throwInvalidOperationError(match[1], parserToken);\n        setFirstInExpression(expression, operatorFunc);\n        return operatorFunc;\n    }\n};\nvar processExpression = function (expression, controller, parserToken) {\n    if (!(expression instanceof Array)) {\n        expression = [expression];\n    }\n    if (expression.length === 3 && !includes(LOGICAL_OPERATORS, getMiddleItem(expression))) {\n        throwError(\"Invalid logical operator [\" + getMiddleItem(expression) + \"] in expression [\" + getExpression(parserToken) + \"]\");\n    }\n    if (!untilTruthy(function () { return processEquality(expression, controller, parserToken); }, function () { return processExplicitPrecedence(expression, controller, parserToken); }, function () { return processLogicalOperation('&&', expression, controller, parserToken); }, function () { return processLogicalOperation('||', expression, controller, parserToken); }) && (expression.length % 2) === 1 && !isFunction(getFirstInExpression(expression))) {\n        throwInvalidExpressionError(parserToken);\n    }\n    if (expression.length > 1 || !isFunction(getFirstInExpression(expression))) {\n        return processExpression(expression, controller, parserToken);\n    }\n    else {\n        return expression;\n    }\n};\n/* Exported Functions\n----------------------------------------------------------------*/\nexports.getFields = function (token) { return expressionCache[token].fields; };\nexports.deleteFromCache = function (token) { return delete expressionCache[token]; };\nexports.generateRandomKey = function () { return Math.floor((1 + Math.random()) * 0x100000000000000).toString(16).substring(1); };\nexports.buildEvaluator = function (expression, controller, parserToken) {\n    var match = matchExpression(expression) || [];\n    expressionCache[parserToken] = { expression: expression };\n    if (match.length % 2 === 0) {\n        throwInvalidExpressionError(parserToken);\n    }\n    var result = processExpression(match, controller, parserToken);\n    return getFirstInExpression(result);\n};\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar evaluation_builder_1 = __webpack_require__(0);\n/**\n * Expression parser class\n */\nvar default_1 = (function () {\n    /**\n     * Creates new instance of the ExpressionParser.\n     * @param _expression Expression to be parsed\n     * @param _controller Object with fields that will be evaluated\n     */\n    function default_1(_expression, _controller) {\n        this._expression = _expression;\n        this._controller = _controller;\n        this._parserToken = evaluation_builder_1.generateRandomKey();\n    }\n    Object.defineProperty(default_1.prototype, \"fields\", {\n        /**\n         * Object fields that were used in the expression.\n         */\n        get: function () {\n            return this._fields;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(default_1.prototype, \"currentEvaluator\", {\n        /**\n         * Returns the current evaluator function without triggering it like the evaluate() function does.\n         */\n        get: function () {\n            return this._evaluator;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Evaluates current instance of the Expression Parser and returns\n     * a boolean value based on the expression that was passed in the constructor.\n     */\n    default_1.prototype.evaluate = function () {\n        if (!this._evaluator) {\n            this._evaluator = evaluation_builder_1.buildEvaluator(this._expression, this._controller, this._parserToken);\n            this._fields = evaluation_builder_1.getFields(this._parserToken);\n            evaluation_builder_1.deleteFromCache(this._parserToken);\n        }\n        return this._evaluator();\n    };\n    return default_1;\n}());\nexports.default = default_1;\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// goat.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3524004c0082023ff56e","/* Constants\n----------------------------------------------------------------*/\n\nconst EQUALITY_REGEX = /^\\s*([^\\sˆ&|\\'\"\\(\\)]+|[\"'][^'\"]+[\"'])\\s*$|^\\s*([^\\sˆ&|\\'\"\\(\\)]+|[\"'][^'\"]*[\"'])\\s*([^'\"\\w\\s|&]{1,3})\\s*([^\\sˆ&|\\'\"\\(\\)]+|[\"'][^'\"]*[\"'])\\s*$/;\nconst STRING_REGEX = /^['\"](.*)['\"]$/;\nconst NOT_REGEX = /^\\s*([!]+)\\s*(\\w+)\\s*$/;\nconst LOGICAL_OPERATORS = ['&&', '||'];\nconst RELATIONAL_OPERATORS = ['==', '!=', '===', '!==', '!', '>=', '<=', '>', '<'];\n\n/* Types\n----------------------------------------------------------------*/\n\ntype Evaluator = () => boolean;\ntype ControllerFn = (obj: IKeyValue<any>) => any;\ntype Operand = string | Evaluator;\ntype Expression = RegExpMatchArray | Array<Operand>;\n\nexport interface IKeyValue<T> {\n    [key: string]: T;\n}\n\nexport interface IKeyFunction extends IKeyValue<() => boolean> {\n}\n\nexport interface IExpressionCache { \n    fields?: string[];\n    expression: string;\n}\n\n/* Cache Variables\n----------------------------------------------------------------*/\n\nconst expressionCache: IKeyValue<IExpressionCache> = {};\n\n/* Support Functions\n----------------------------------------------------------------*/\n\nconst isBoolean = (value: string) => ['true', 'false'].indexOf(value) > -1;\nconst isFunction = (o: any) => typeof o === 'function';\nconst includes = <T>(o: T[], value: T) => o.indexOf(value) > -1;\nconst getMiddleItem = (expression: Expression) => expression[Math.round((expression.length - 1) / 2)];\n\nconst matchExpression = (expression: string) => \n    expression.match(/([&|]{2})|([\\(\\)])|([^\\sˆ&|\\'\"\\(\\)]+|[\"'].+[\"'])\\s*([^\\w\\s|&\\(\\)]{1,3})?\\s*([^\\sˆ&|\\(\\)]+)?/g);\n\nconst isProperty = (expression: string) => /^\\s*([a-z]\\w+)(\\.[a-z]\\w+)*\\s*$/g.test(expression);\n\nconst asFunction = (val: any) => isFunction(val) ? val() : val;\n\nconst setFirstInExpression = (expression: Expression, value: Operand) => (expression as Array<Operand>)[0] = value;\nconst getFirstInExpression = <T extends Operand>(expression: Expression) => <T>(expression as Array<Operand>)[0];\n\nconst getRegexMatchArray = (regex: RegExp, input: string) => {\n    let match: string[] = regex.exec(input) || [];\n    if (match.length === 0) return;\n    match = match.filter(m => m !== undefined);\n    match.shift();\n    return match;\n};\n\nconst getExpression = (token: string) => expressionCache[token].expression;\n\nconst throwError = (...msg: string[]) => { throw new Error(msg.join('')); };\nconst throwInvalidOperationError = (operator: string, token: string) => throwError(`Operator [${operator}] is not valid in expression [${getExpression(token)}]`);\nconst throwInvalidExpressionError = (token: string) => throwError(`Invalid expression [${getExpression(token)}]`);\n\nconst getOperation = (operation: string, left: Operand, right?: Operand) => (<IKeyFunction>{\n    '==': () => asFunction(left) == asFunction(right),\n    '!=': () => asFunction(left) != asFunction(right),\n    '===': () => asFunction(left) === asFunction(right),\n    '!==': () => asFunction(left) !== asFunction(right),\n    '<=': () => asFunction(left) <= asFunction(right),\n    '>=': () => asFunction(left) >= asFunction(right),\n    '<': () => asFunction(left) < asFunction(right),\n    '>': () => asFunction(left) > asFunction(right),\n    '&&': () => asFunction(left) && asFunction(right),\n    '||': () => asFunction(left) || asFunction(right)\n})[operation];\n\nconst evaluateNot = (nots: string[], value: string, controller: IKeyValue<any>, parserToken: string) => {\n    let evaluate: Operand;\n    nots.shift();\n    if (nots.length) {\n        evaluate = evaluateNot(nots, value, controller, parserToken);\n    }\n\n    const operand = processOperand(value, controller, parserToken);\n    return () => !asFunction(evaluate || operand);\n};\n\nconst buildPropertyCaller = (fields: string[], lastFunction?: ControllerFn): ControllerFn => {\n    const last = fields[fields.length - 1];\n    fields.pop();\n\n    // function that evaluates current property\n    let fn: ControllerFn;\n\n    if (!lastFunction) {\n        fn = (obj) => obj[last];\n    } else {\n        fn = (obj) => lastFunction(obj[last]);\n    }\n\n    if (fields.length) {\n        return buildPropertyCaller(fields, fn);\n    }\n\n    return fn;\n};\n\nconst setField = (field: string, parserToken: string) => {\n    let cache = expressionCache[parserToken].fields;\n    if (!cache) {\n        cache = expressionCache[parserToken].fields = [];\n    }\n    cache.push(field);\n};\n\n/**\n * Executes functions in series until one of them returns a truthy value.\n * If it does, the function returns true.\n * @param fns Functions to be executed\n */\nconst untilTruthy = (...fns: Function[]) => !fns.every((fn) => !fn());\n\n/* Processing Functions\n----------------------------------------------------------------*/\n\nconst processOperand = (m: any, controller: IKeyValue<any>, parserToken: string): any => {\n    let match;\n    if ((match = getRegexMatchArray(NOT_REGEX, m))) {\n        const nots = match[0].split('');\n        return evaluateNot(nots, match[1], controller, parserToken);\n    } else if (isBoolean(m)) {\n        return m === 'true';\n    } else if (isProperty(m)) {\n        const caller = buildPropertyCaller(m.split('.'));\n        setField(m, parserToken);\n        return () => caller(controller);\n    } else if (!isNaN(m)) {\n        return parseInt(m);\n    } else if ((match = STRING_REGEX.exec(m))) {\n        return getMiddleItem(match);\n    }\n    \n    throwInvalidExpressionError(parserToken);\n};\n\nconst processLogicalOperation = (operation: string, expression: any, controller: IKeyValue<any>, parserToken: string) => {\n    let index = -1;\n    let leftIndex = 0;\n    let rightIndex = 0;\n    if ((index = expression.indexOf(operation)) > -1 && \n        (expression[leftIndex = index - 1] !== ')') &&\n        (expression[rightIndex = index + 1] !== '(')) {\n        let left = processExpression(expression[leftIndex], controller, parserToken);\n        let right = processExpression(expression[rightIndex], controller, parserToken);\n        const result = getOperation(operation, getFirstInExpression(left), getFirstInExpression(right));\n        expression[leftIndex] = result;\n        expression.splice(index, 2);\n\n        return result;\n    }\n};\n\nconst processExplicitPrecedence = (expression: any, controller: IKeyValue<any>, parserToken: string) => {\n    let subExpression = expression;\n    const indexLeftParenthesis = expression.lastIndexOf('(');\n    if (indexLeftParenthesis > -1) {\n        subExpression = subExpression.slice(indexLeftParenthesis + 1, subExpression.length);\n        const indexRightParenthesis = subExpression.indexOf(')');\n        subExpression = subExpression.slice(0, indexRightParenthesis);\n        const expressionLength = subExpression.length;\n        const result = processExpression(subExpression, controller, parserToken);\n        expression[indexLeftParenthesis] = result;\n        expression.splice(indexLeftParenthesis + 1, expressionLength + 1);\n        return result;\n    }\n};\n\nconst processEquality = (expression: Expression, controller: IKeyValue<any>, parserToken: string) => {\n    let match: RegExpMatchArray;\n    let operatorFunc: Evaluator;\n    if (expression.length === 1 && (match = getRegexMatchArray(EQUALITY_REGEX, getFirstInExpression<string>(expression)))) {\n        const left = processOperand(match[0], controller, parserToken);\n        let right = match[2];\n        if (right) {\n            right = processOperand(match[2], controller, parserToken);\n        }\n\n        const operation = match[1];\n        if (isFunction(left) && !right && !operation) {\n            operatorFunc = left as () => boolean;\n        } else {\n            operatorFunc = getOperation(match[1], left, right);\n        }\n\n        if (!operatorFunc) throwInvalidOperationError(match[1], parserToken);\n\n        setFirstInExpression(expression, operatorFunc);\n\n        return operatorFunc;\n    }\n};\n\nconst processExpression = (expression: Expression, controller: IKeyValue<any>, parserToken: string): Expression => {\n    if (!(expression instanceof Array)) {\n        expression = [expression];\n    }\n\n    if (expression.length === 3 && !includes(LOGICAL_OPERATORS, getMiddleItem(expression))) {\n        throwError(`Invalid logical operator [${<string>getMiddleItem(expression)}] in expression [${getExpression(parserToken)}]`);\n    }\n\n    if (!untilTruthy(\n        () => processEquality(expression, controller, parserToken),\n        () => processExplicitPrecedence(expression, controller, parserToken),\n        () => processLogicalOperation('&&', expression, controller, parserToken),\n        () => processLogicalOperation('||', expression, controller, parserToken)\n    ) && (expression.length % 2) === 1 && !isFunction(getFirstInExpression(expression))) {\n        throwInvalidExpressionError(parserToken);\n    }\n\n    if (expression.length > 1 || !isFunction(getFirstInExpression(expression))) {\n        return processExpression(expression, controller, parserToken);\n    } else {\n        return expression;\n    }\n};\n\n/* Exported Functions\n----------------------------------------------------------------*/\n\nexport const getFields = (token: string) => expressionCache[token].fields;\nexport const deleteFromCache = (token: string) => delete expressionCache[token];\n\nexport const generateRandomKey = () => Math.floor((1 + Math.random()) * 0x100000000000000).toString(16).substring(1);\n\nexport const buildEvaluator = (expression: string, controller: IKeyValue<any>, parserToken: string): Evaluator => {\n    const match = matchExpression(expression) || [];\n\n    expressionCache[parserToken] = { expression: expression };\n    \n    if (match.length % 2 === 0) {\n        throwInvalidExpressionError(parserToken);\n    }    \n\n    const result = processExpression(match, controller, parserToken);\n\n    return getFirstInExpression<Evaluator>(result);\n};\n\n\n// WEBPACK FOOTER //\n// ./src/evaluation.builder.ts","import { generateRandomKey, buildEvaluator, getFields, deleteFromCache } from './evaluation.builder';\n\n/**\n * Expression parser class\n */\nexport default class {\n    private _evaluator: () => boolean;\n    private _fields: string[];\n    private _parserToken: string;\n\n    /**\n     * Object fields that were used in the expression.\n     */\n    public get fields(): string[] {\n        return this._fields;\n    }\n\n    /**\n     * Returns the current evaluator function without triggering it like the evaluate() function does.\n     */\n    public get currentEvaluator() {\n        return this._evaluator;\n    }\n\n    /**\n     * Creates new instance of the ExpressionParser.\n     * @param _expression Expression to be parsed\n     * @param _controller Object with fields that will be evaluated\n     */\n    constructor (private _expression: string, private _controller: { [key: string]: any }) {\n        this._parserToken = generateRandomKey();\n    }\n    \n    /**\n     * Evaluates current instance of the Expression Parser and returns\n     * a boolean value based on the expression that was passed in the constructor.\n     */\n    public evaluate() {\n        if (!this._evaluator) {\n            this._evaluator = buildEvaluator(this._expression, this._controller, this._parserToken);\n            this._fields = getFields(this._parserToken);\n            deleteFromCache(this._parserToken);\n        }\n\n        return this._evaluator();\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/expression.parser.ts"],"sourceRoot":""}